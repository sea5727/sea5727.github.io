---
layout: archive
title: "multi-thread program synchronization #2"
date: 2021-05-13 01:32:12 +0900
categories: cs 
tag:
- computer_science
blog: true
author: ysh
description: 
comments: true
---



## lock

스레드가 코드를 실행하면서 lock을 만날때 경우의수는 3가지가 있습니다. 

1. lock이 다른스레드에게 점유가 되어 있지 않은 경우
2. lock이 다른스레드에게 점유가 되어 있는 경우
3. lock이 같은 스레드게 점유가 된 경우


## lock이 다른 스레드에게 점유되어 있지 않은경우
스레드는 lock을 점유하고 코드를 진행하게 됩니다. 언어별로 지원하는 락의 모습이 다를 수 있으나, 근본적으로 같은 개념입니다. lock ~ unlock 까지 점유하지 않은 스레드의 접근을 막아줍니다. 

## lock이 다른 스레드에게 이미 점유가 된 경우
스레드는 차단이 발생하고 대기상태에 들어갑니다. 이후에는 운영체제 스케쥴링에 의해서 스케쥴링되어 대기? 슬립? 상태가되며, 스레드가 운영체제에 의해 깨어났을때  다시 락의 유무를 확인하고 락을 점유하여 진행할지, 다시 대기상태가 될지 판단합니다. 


#### mutex
`mutual exclusion` 의 줄임말로 `mutex` 입니다. 일반적으로 프로그램 내에서 스레드간에 코드에 대해 임계영역(critical section)을 제공해줍니다. 임계영역으로 진입할때 mutex를 점유하고, 나올때 mutex를 해제하여 임계영역을 사용하는 스레드만이 해제가 가능합니다.

#### semaphore
일반적으로 여러개의 프로세스간에 공유자원에 대해서 임계영역을 제공해줍니다. 내부적으로는 1,0 또는 그이상의 flag를 사용하여 동작한다고 합니다. 외부에서도 임계영역에 대한 해제를 할수있습니다.

#### lock
mutex, semaphore 와 같이 상호배제를 제공해주는 기능포함하여 제공해주는 객체입니다. 일반적으로 mutex 일수도, semaphore 일수도, 내부적으로 구현된 객체일수도 있습니다. 즉 lock이란 실제 구현물일수도 있으며, 추상적인 개념일 수도 있습니다. 

#### critical section
여러 스레드/프로세스들의 공유자원에 대해서 상호 배제를 제공하는 공간입니다. 코드상의 일부분, 스코프, 함수가 그 대상이 될 수 있습니다.

#### deadlock
스레드들이 임계영역에 진입하지 못하고 모두 대기상태가 되어있는 경우입니다. lock을 점유하고 해제하지 못하였거나, `race condition` 으로 인해 서로 다른 스레드들이 이미 락을 점유한 서로의 lock을 점유하고자 할때 발생 할 수 있습니다. 

#### busy wait
반복문을통해서 끊임없이 조건을 확인하고 대기하는 기법입니다. 일반적으로 cpu점유율이 높을수있습니다. 

#### spinlock 
busy wait 기법을 사용하여 운영체제에 스레드 스케쥴링을 반납하지않고 직접 진행상태를 확인하는 기법입니다. lock 점유시간이 짧은 경우에 운영체제의 스케쥴링보다 더 효율적일 수 있습니다.

#### condition variable
mutex 개념으로부터 나온 기능? 입니다. wait상태로 스레드를 대기시킬수 있으며, notify로 대기중인 스레드를 깨우거나, 대기중인 여러 쓰레드들중 하나를 깨우도록 할수 있습니다. 일반적으로 `producer-consumer` 구조에서 스레드들간 동기화를 위해 사용되곤 합니다.

## lock이 같은 스레드에게 점유가 된 경우
lock 종류에 따라 다르게 동작합니다. 두번 점유된경우 deadlock이 될수도있으며, 같은 스레드에서는 다중점유를 허락하는 락도 있습니다.

